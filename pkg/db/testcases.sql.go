// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: testcases.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTestCase = `-- name: CreateTestCase :one
INSERT INTO testcases (
    id,
    expected_output,
    memory,
    input,
    hidden,
    runtime,
    question_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, expected_output, memory, input, hidden, runtime, question_id
`

type CreateTestCaseParams struct {
	ID             uuid.UUID
	ExpectedOutput string
	Memory         pgtype.Numeric
	Input          *string
	Hidden         bool
	Runtime        pgtype.Numeric
	QuestionID     uuid.UUID
}

func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) (Testcase, error) {
	row := q.db.QueryRow(ctx, createTestCase,
		arg.ID,
		arg.ExpectedOutput,
		arg.Memory,
		arg.Input,
		arg.Hidden,
		arg.Runtime,
		arg.QuestionID,
	)
	var i Testcase
	err := row.Scan(
		&i.ID,
		&i.ExpectedOutput,
		&i.Memory,
		&i.Input,
		&i.Hidden,
		&i.Runtime,
		&i.QuestionID,
	)
	return i, err
}

const deleteTestCase = `-- name: DeleteTestCase :exec
DELETE FROM testcases
WHERE id = $1
`

func (q *Queries) DeleteTestCase(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTestCase, id)
	return err
}

const getAllTestCases = `-- name: GetAllTestCases :many
SELECT
    id,
    expected_output,
    memory,
    input,
    hidden,
    runtime,
    question_id
FROM testcases
`

func (q *Queries) GetAllTestCases(ctx context.Context) ([]Testcase, error) {
	rows, err := q.db.Query(ctx, getAllTestCases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Testcase
	for rows.Next() {
		var i Testcase
		if err := rows.Scan(
			&i.ID,
			&i.ExpectedOutput,
			&i.Memory,
			&i.Input,
			&i.Hidden,
			&i.Runtime,
			&i.QuestionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTestCasesByQuestion = `-- name: GetAllTestCasesByQuestion :many
SELECT
    id,
    memory,
    expected_output,
    input,
    hidden,
    runtime,
    question_id
FROM testcases
WHERE question_id = $1
`

type GetAllTestCasesByQuestionRow struct {
	ID             uuid.UUID
	Memory         pgtype.Numeric
	ExpectedOutput string
	Input          *string
	Hidden         bool
	Runtime        pgtype.Numeric
	QuestionID     uuid.UUID
}

func (q *Queries) GetAllTestCasesByQuestion(ctx context.Context, questionID uuid.UUID) ([]GetAllTestCasesByQuestionRow, error) {
	rows, err := q.db.Query(ctx, getAllTestCasesByQuestion, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTestCasesByQuestionRow
	for rows.Next() {
		var i GetAllTestCasesByQuestionRow
		if err := rows.Scan(
			&i.ID,
			&i.Memory,
			&i.ExpectedOutput,
			&i.Input,
			&i.Hidden,
			&i.Runtime,
			&i.QuestionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicTestCasesByQuestion = `-- name: GetPublicTestCasesByQuestion :many
SELECT
    id,
    memory,
    input,
    hidden,
    runtime,
    question_id
FROM testcases
WHERE question_id = $1
AND hidden = false
`

type GetPublicTestCasesByQuestionRow struct {
	ID         uuid.UUID
	Memory     pgtype.Numeric
	Input      *string
	Hidden     bool
	Runtime    pgtype.Numeric
	QuestionID uuid.UUID
}

func (q *Queries) GetPublicTestCasesByQuestion(ctx context.Context, questionID uuid.UUID) ([]GetPublicTestCasesByQuestionRow, error) {
	rows, err := q.db.Query(ctx, getPublicTestCasesByQuestion, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicTestCasesByQuestionRow
	for rows.Next() {
		var i GetPublicTestCasesByQuestionRow
		if err := rows.Scan(
			&i.ID,
			&i.Memory,
			&i.Input,
			&i.Hidden,
			&i.Runtime,
			&i.QuestionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCase = `-- name: GetTestCase :one
SELECT
    id,
    expected_output,
    memory,
    input,
    hidden,
    runtime,
    question_id
FROM testcases
WHERE id = $1
`

func (q *Queries) GetTestCase(ctx context.Context, id uuid.UUID) (Testcase, error) {
	row := q.db.QueryRow(ctx, getTestCase, id)
	var i Testcase
	err := row.Scan(
		&i.ID,
		&i.ExpectedOutput,
		&i.Memory,
		&i.Input,
		&i.Hidden,
		&i.Runtime,
		&i.QuestionID,
	)
	return i, err
}

const getTestCasesByQuestion = `-- name: GetTestCasesByQuestion :many
SELECT
    id,
    memory,
    input,
    hidden,
    runtime,
    question_id
FROM testcases
WHERE question_id = $1
`

type GetTestCasesByQuestionRow struct {
	ID         uuid.UUID
	Memory     pgtype.Numeric
	Input      *string
	Hidden     bool
	Runtime    pgtype.Numeric
	QuestionID uuid.UUID
}

func (q *Queries) GetTestCasesByQuestion(ctx context.Context, questionID uuid.UUID) ([]GetTestCasesByQuestionRow, error) {
	rows, err := q.db.Query(ctx, getTestCasesByQuestion, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestCasesByQuestionRow
	for rows.Next() {
		var i GetTestCasesByQuestionRow
		if err := rows.Scan(
			&i.ID,
			&i.Memory,
			&i.Input,
			&i.Hidden,
			&i.Runtime,
			&i.QuestionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTestCase = `-- name: UpdateTestCase :one
UPDATE testcases
SET
    expected_output = $2,
    memory = $3,
    input = $4,
    hidden = $5,
    runtime = $6,
    question_id = $7
WHERE id = $1
RETURNING id, expected_output, memory, input, hidden, runtime, question_id
`

type UpdateTestCaseParams struct {
	ID             uuid.UUID
	ExpectedOutput string
	Memory         pgtype.Numeric
	Input          *string
	Hidden         bool
	Runtime        pgtype.Numeric
	QuestionID     uuid.UUID
}

func (q *Queries) UpdateTestCase(ctx context.Context, arg UpdateTestCaseParams) (Testcase, error) {
	row := q.db.QueryRow(ctx, updateTestCase,
		arg.ID,
		arg.ExpectedOutput,
		arg.Memory,
		arg.Input,
		arg.Hidden,
		arg.Runtime,
		arg.QuestionID,
	)
	var i Testcase
	err := row.Scan(
		&i.ID,
		&i.ExpectedOutput,
		&i.Memory,
		&i.Input,
		&i.Hidden,
		&i.Runtime,
		&i.QuestionID,
	)
	return i, err
}
